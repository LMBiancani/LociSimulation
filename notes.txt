NOTES - LociSimulation
github: https://github.com/LMBiancani/LociSimulation.git
Project="/scratch4/workspace/biancani_uri_edu-LociSimulation"

2025.10.09

ws_allocate -m biancani@uri.edu -r 5 -G pi_rsschwartz_uri_edu LociSimulation 30

Info: creating workspace.
/scratch4/workspace/biancani_uri_edu-LociSimulation
remaining extensions  : 5
remaining time in days: 30

Starting with mammal loci from https://github.com/LMBiancani/PlacentalPolytomy
Original Path to aligned loci:
"/data/schwartzlab/Biancani/PlacentalPolytomy/output/01_SISRS_loci_filtered"

2025.10.09

cd /scratch4/workspace/biancani_uri_edu-LociSimulation

copy mammal loci to scratch space:

transfer.sh
---------------------------------
#!/bin/bash
#SBATCH --job-name="tar_transfer"
#SBATCH --time=48:00:00  # walltime limit (HH:MM:SS)
#SBATCH --mail-user="biancani@uri.edu"
#SBATCH --mail-type=ALL
#SBATCH --nodes=1
#SBATCH --ntasks-per-node=1
#SBATCH -p uri-cpu
#SBATCH --cpus-per-task=1
#SBATCH --mem-per-cpu=6G

# Define source and destination directories
SOURCE_DIR="/data/schwartzlab/Biancani/PlacentalPolytomy/output/01_SISRS_loci_filtered"
DEST_DIR="/scratch4/workspace/biancani_uri_edu-LociSimulation/mammal_loci"

# Make sure the destination exists
mkdir -p "$DEST_DIR"
echo "Started at $(date)"

# Stream the directory (preserving its name) to scratch
tar -cf - -C "$(dirname "$SOURCE_DIR")" "$(basename "$SOURCE_DIR")" | pv | tar -xf - -C "$DEST_DIR"

echo "Finished at $(date)"
---------------------------------
sbatch transfer.sh
Submitted batch job 45655769

sacct -j 45655769 -o JobID,ExitCode,Elapsed,MaxRSS
JobID        ExitCode    Elapsed     MaxRSS
------------ -------- ---------- ----------
45655769          0:0   00:01:48
45655769.ba+      0:0   00:01:48   2114772K
45655769.ex+      0:0   00:01:48          0

mkdir /scratch4/workspace/biancani_uri_edu-LociSimulation/LociSimulation

github: https://github.com/LMBiancani/LociSimulation.git

2025.10.20

Use git subtree to copy Molly's updated simulation/machine learning scripts (and preserve commit history)
Molly's repo: https://github.com/mollyodonnellan/PML.git

cd /scratch4/workspace/biancani_uri_edu-LociSimulation/LociSimulation
git subtree add --prefix=Scripts https://github.com/mollyodonnellan/PML.git main

Mammal data is too large for AMAS so script needs updating to run through loci in batches.

run_amas.py is a custom batch concatenation wrapper around AMAS.
It processes FASTA alignments in chunks of 1000 files at a time (to avoid overloading AMAS input limitations), concatenates them, and appends the results into cumulative files.
Outputs:
concatenated.fasta
partitions.txt

cd /scratch4/workspace/biancani_uri_edu-LociSimulation/LociSimulation/Scripts/0_data_prep

nano run_amas.py
---------------------------------
#!/usr/bin/env python3
"""
run_amas.py
------------
Concatenates FASTA alignments in batches using AMAS (to avoid overloading AMAS input limitations).
Creates a concatenated alignment file and a corresponding partition file:
concatenated.fasta
partitions.txt

Usage:
    python run_amas.py <fasta_folder> <num_cores> <path_to_AMAS.py>
"""

import sys
import glob
import subprocess
import os

# --- Input arguments ---
fasta_folder = sys.argv[1]
total_cores = sys.argv[2]
amas = sys.argv[3]

# --- Collect all fasta files ---
files = glob.glob(os.path.join(fasta_folder, "*.fasta"))
files.sort()  # ensure consistent, reproducible order

batch_size = 1000
batch_outputs = []
batch_parts = []

count = 0
fileList = []
batch_num = 1

# --- Process loci in batches ---
for f in files:
    fileList.append(f)
    count += 1

    if count == batch_size:
        batch_fasta = f"amas_batch_{batch_num}.fasta"
        batch_part = f"partitions_batch_{batch_num}.txt"

        cmd = (
            f"python3 {amas} concat "
            f"-f fasta -d dna --out-format fasta --part-format raxml "
            f"-i {' '.join(fileList)} "
            f"-c {total_cores} -t {batch_fasta} -p {batch_part}"
        )
        print(f"\n=== Running AMAS on batch {batch_num} ({len(fileList)} files) ===")
        subprocess.call(cmd, shell=True)

        batch_outputs.append(batch_fasta)
        batch_parts.append(batch_part)
        fileList = []
        count = 0
        batch_num += 1

# --- Final partial batch (if any) ---
if len(fileList) > 0:
    batch_fasta = f"amas_batch_{batch_num}.fasta"
    batch_part = f"partitions_batch_{batch_num}.txt"

    cmd = (
        f"python3 {amas} concat "
        f"-f fasta -d dna --out-format fasta --part-format raxml "
        f"-i {' '.join(fileList)} "
        f"-c {total_cores} -t {batch_fasta} -p {batch_part}"
    )
    print(f"\n=== Running AMAS on final batch {batch_num} ({len(fileList)} files) ===")
    subprocess.call(cmd, shell=True)

    batch_outputs.append(batch_fasta)
    batch_parts.append(batch_part)

# --- Final concatenation across all batches ---
print("\n=== Performing final concatenation across batches ===")

cmd_final = (
    f"python3 {amas} concat "
    f"-f fasta -d dna --out-format fasta --part-format raxml "
    f"-i {' '.join(batch_outputs)} "
    f"-c {total_cores} -t concatenated.fasta -p partitions.txt"
)
subprocess.call(cmd_final, shell=True)

# --- Cleanup temporary batch files ---
print("\n=== Cleaning up intermediate files ===")
for f in batch_outputs + batch_parts:
    try:
        os.remove(f)
    except OSError:
        print(f"Warning: could not remove {f}")

print("\n=== run_amas.py execution completed. ===")
print("Output files:")
print(" - concatenated.fasta")
print(" - partitions.txt\n")
---------------------------------

0.0_amas_concat.sh runs AMAS on an empirical dataset to concatenate input fasta files and prepare partitions ahead of IQTree run.
Uses a helper Python script (run_amas.py), which wraps around the AMAS.py concat command.

cd /scratch4/workspace/biancani_uri_edu-LociSimulation/LociSimulation/Scripts/0_data_prep

nano 0.0_amas_concat.sh
---------------------------------
#!/bin/bash
#SBATCH --job-name="AMAS"
#SBATCH --time=2:00:00  # walltime limit (HH:MM:SS)
#SBATCH --nodes=1   # number of nodes
#SBATCH --ntasks-per-node=1   # processor core(s) per node
#SBATCH --cpus-per-task=1
#SBATCH --mem-per-cpu=10G
#SBATCH -p uri-cpu
#SBATCH --mail-user="biancani@uri.edu" #CHANGE THIS to your user email address
#SBATCH --mail-type=ALL

# --- Variables ---
# Path to project directory:
Project="/scratch4/workspace/biancani_uri_edu-LociSimulation"
# Path to scripts directory:
Scripts="$Project/LociSimulation/Scripts"
# Path to output directory (will be created if necessary)
Output="$Project/output/mammals"
# Path to aligned loci in fasta format:
Data="$Project/mammal_loci/01_SISRS_loci_filtered"
# Path to AMAS executable:
AMAS="/project/pi_rsschwartz_uri_edu/Biancani/Software/AMAS/amas/AMAS.py"
# Number of processor cores per node:
Cores=$(echo $SLURM_TASKS_PER_NODE | sed 's/(x.*)//')

module purge
module load uri/main Python/3.7.4-GCCcore-8.3.0

date
mkdir -p ${Output}/0.0_concatenated
cd ${Output}/0.0_concatenated

#Concatenate input fasta files and prepare partitions ahead of IQTree run
python3 ${Scripts}/0_data_prep/run_amas.py ${Data} ${Cores} ${AMAS}

date
---------------------------------
sbatch 0.0_amas_concat.sh
Submitted batch job 49112018
sacct -j 49112018 -o JobID,ExitCode,Elapsed,MaxRSS
JobID        ExitCode    Elapsed     MaxRSS
------------ -------- ---------- ----------
49112018          0:0   00:01:39
49112018.ba+      0:0   00:01:39   5584204K
49112018.ex+      0:0   00:01:40          0

cd /scratch4/workspace/biancani_uri_edu-LociSimulation/LociSimulation/Scripts/0_data_prep

0.1_iqtree_empirical.sh will use iqtree to infer an empirical tree.

nano 0.1_iqtree_empirical.sh
---------------------------------
#!/bin/bash
#SBATCH --job-name="IQTREE"
#SBATCH --time=96:00:00  # walltime limit (HH:MM:SS)
#SBATCH --nodes=1
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=24
#SBATCH --mem=250G
#SBATCH -p uri-cpu
#SBATCH --mail-user="biancani@uri.edu" #CHANGE THIS to your user email address
#SBATCH --mail-type=ALL

# --- Variables ---
# Path to project directory:
Project="/scratch4/workspace/biancani_uri_edu-LociSimulation"
# Path to output directory
Output="$Project/output/mammals"
# Path to IQTREE executable:
IQTREE="/project/pi_rsschwartz_uri_edu/Biancani/Software/iqtree-2.1.2-Linux/bin/iqtree2"
# Path to output files from 0.0_amas_concat.sh
Input="$Output/0.0_concatenated"
# Number of cpus per task:
Threads=${SLURM_CPUS_PER_TASK}

module purge

date
mkdir -p ${Output}/0.1_empirical_tree
cd ${Output}/0.1_empirical_tree

# --- Check for input files produced by 0.0_amas_concat.sh---

if [[ ! -f "$Input/concatenated.fasta" || ! -f "$Input/partitions.txt" ]]; then
    echo "Error: concatenated.fasta or partitions.txt not found in ${Input}"
    exit 1
fi

# --- Run IQ-TREE ---
# Flags:
#   -nt: number of CPU threads
#   -spp: partition file allowing different evolutionary rates per partition
#   -pre: prefix for output files
#   -m MFP: ModelFinder Plus for best-fit model selection
#   -bb: ultrafast bootstrap replicates
#   -alrt: SH-like approximate likelihood test replicates

${IQTREE} -nt ${Threads} \
    -s $Input/concatenated.fasta \
    -spp $Input/partitions.txt \
    -pre inferenceEmpirical \
    -m MFP -bb 1000 -alrt 1000

date
---------------------------------
sbatch 0.1_iqtree_empirical.sh
Submitted batch job 47065851
sacct -j 47065851 -o JobID,ExitCode,Elapsed,MaxRSS
JobID        ExitCode    Elapsed     MaxRSS
------------ -------- ---------- ----------
47065851          0:0 2-17:22:51
47065851.ba+      0:0 2-17:22:51 149134624K
47065851.ex+      0:0 2-17:22:51       256K

2025.11.21

cd /scratch4/workspace/biancani_uri_edu-LociSimulation/LociSimulation/Scripts/1_prep_empirical_tree

nano install.packages.R
---------------------------------
# Capture command-line arguments (package names to check and install)
args <- commandArgs(trailingOnly = TRUE)

if (length(args) == 0) {
  stop("Error: No package names provided as arguments. Exiting.", call. = FALSE)
}

# The packages to install are now in the 'args' vector
packages_to_install <- args

# Function to check, install, and load packages
install_and_load <- function(pkg) {
  # Check if the package is installed
  if (!requireNamespace(pkg, quietly = TRUE)) {
    message(paste("Package", pkg, "not found. Installing..."))
    # Install the package from CRAN
    install.packages(pkg, dependencies = TRUE, repos = "https://cloud.r-project.org")
  } else {
    message(paste("Package", pkg, "is already installed."))
  }

  # Load the package (library function)
  library(pkg, character.only = TRUE)
  message(paste("Package", pkg, "loaded successfully."))
}

# Apply the function to the list of packages
invisible(sapply(packages_to_install, install_and_load))
---------------------------------

cd /scratch4/workspace/biancani_uri_edu-LociSimulation/LociSimulation/Scripts/1_prep_empirical_tree

### nano empirical_tree_processor.R
### ---------------------------------
### ## Capture Command Line Arguments
###
### # Arguments must be passed in the following order:
### # [1] mod_write_tree2     (Path to modified.write.tree2.R - script that adjusts how ape handles tree files)
### # [2] treefile            (Path to the input .treefile - generated by 0.1_iqtree_empirical.sh)
### # [3] format_tree_out     (Base directory for output files)
### # [4] out_tip             (The tip name to use as the outgroup for rooting)
### # [5] tree_depth          (Estimated age in years of most recent common ancestor of all species in the tree)
### # [6] gen_time            (Estimated generation time in years for all species in the tree)
### # [7] simphy_seed1        (First random number seed for generate_params.txt)
### # [8] simphy_seed2        (Second random number seed for generate_params.txt)
###
### args <- commandArgs(trailingOnly = TRUE)
###
### # Check if the correct number of arguments was provided
### if (length(args) < 8) {
###   stop("Error: Not enough arguments provided. Expected 8.", call. = FALSE)
### }
###
### # Assign arguments to variables
### mod_write_tree2 <- args[1]
### treefile <- args[2]
### format_tree_out <- args[3]
### out_tip <- args[4]
### simphy_seed1 <- args[7]
### simphy_seed2 <- args[8]
###
### # Calculate the scale factor (Total Generations) from args[5] (depth) and args[6] (gen_time)
### scale_factor <- as.numeric(args[5])/as.numeric(args[6])
###
### # --- 2. Load Libraries and Setup ---
###
### library(ape)
### library(ggplot2)
### library(geiger)
### library(ggtree)
###
### ## Force a headless friendly bitmap device for the session
### options(bitmapType = "cairo")
###
### # Adjust path to modified.write.tree2.R
### source(mod_write_tree2)
### assignInNamespace(".write.tree2", .write.tree2, "ape")
###
### # --- 3. Process and Save Empirical Tree ---
###
### # Empirical tree:
### tree <- read.tree(treefile)
###
### # Root the tree and save the check image
### tree <- root(tree, outgroup = out_tip)
### p <- ggtree(tree) + theme_tree2() + geom_tiplab()
### ggsave(p, file=paste0(format_tree_out, "/tree_check_root.png"))
###
### # Check the tree rooted correctly. Then transform to ultrametric and rescale
###
### tree_um <- chronos(tree)
### class(tree_um) <- "phylo" # Ensure it is a 'phylo' object after chronos
### tree_um <- rescale(tree_um, model = "depth", scale_factor)
###
### # Save the ultrametric tree check image
### q <- ggtree(tree_um) + theme_tree2() + geom_tiplab()
### ggsave(q, file=paste0(format_tree_out, "/tree_um.png"))
###
### # --- 4. Prepare for SimPhy and Write Outputs ---
###
### # Replace labels with numbers, strip node labels, and write out the tree
### tree_um$tip.label <- as.character(1:length(tree_um$tip.label))
### tree_um$node.label <- NULL
### write.tree(tree_um, paste0(format_tree_out, "/s_tree.trees"), digits=8)
###
### # Write the seeds for subsequent dataset parameter simulations
### write(c(simphy_seed1, simphy_seed2), paste0(format_tree_out, "/generate_params.txt"))
###
### print("Tree processing complete and output files saved.")
### ---------------------------------

## INPUTS for empirical_tree_processor.R

# generation scaling factor: Number of generations in the tree: absolute tree age in years divided by average generation time of species in the tree.
total tree depth (years) / average generation time (years)

# total tree depth: age of most recent common ancestor of all species in the tree.
For this mammal data, this would be the age of Theria or age of the common ancestor of placental mammals (ingroup) and marsupials (outgroup)
total tree depth (years) is estimated to be 168 mya
Citations:
2019 - Upham NS, Esselstyn JA, Jetz W (2019) Inferring the mammal tree: Species-level sets of phylogenies for questions in ecology, evolution, and conservation. PLoS Biol 17(12): e3000494.https://doi.org/10.1371/journal.pbio.3000494
168 Fig 1
2017 - Thomas L. Dunwell, Jordi Paps, Peter W. H. Holland; Novel and divergent genes in the evolution of placental mammals. Proc Biol Sci 1 October 2017; 284 (1864): 20171357. https://doi.org/10.1098/rspb.2017.1357
140-191 "The common ancestor of placentals and marsupials dates to approximately 140 – 191 million years ago (Ma)"

tree_depth=168000000

# average generation time (years)
We used a estimated generation time of 4.5 years for Theria. This value is chosen not as the arithmetic mean or median of all extant species (which is skewed by small-bodied rodents and bats), but as a phylogenetically-informed effective generation time that is consistent with the estimated rate of mutation at the deepest nodes of the mammalian tree. This approach accounts for the allometric relationship between body mass and generation length, a relationship thoroughly characterized across Mammalia [cite Pacifici et al., 2013]. Our chosen rate falls within the range utilized by major phylogenomic studies (e.g., Meredith et al., 2011), which established evolutionary rates for ancestral nodes that are consistent with a moderately sized stem mammal ancestor and a generation time in the 4–5 year range."
Citation:
Pacifici, Michela, et al. "Generation length for mammals." Nature Conservation 5 (2013): 89-94.
Meredith, Robert W., et al. "Impacts of the Cretaceous Terrestrial Revolution and KPg extinction on mammal diversification." science 334.6055 (2011): 521-524.

gen_time=4.5

cd /scratch4/workspace/biancani_uri_edu-LociSimulation/LociSimulation/Scripts/1_prep_empirical_tree

### nano 1.0_format_tree.sh - OLD VERSION
### ---------------------------------
### #!/bin/bash
### #SBATCH --job-name="process_tree"
### #SBATCH --time=72:00:00                # Walltime limit (HH:MM:SS)
### #SBATCH --nodes=1                      # Number of nodes
### #SBATCH --ntasks=1                     # Total number of tasks (processes)
### #SBATCH --cpus-per-task=2              # Number of CPU cores per task
### #SBATCH --mem-per-cpu=6G               # Memory per cpu
### #SBATCH --mail-user="biancani@uri.edu" # CHANGE TO user email address
### #SBATCH --mail-type=ALL
### #SBATCH -p uri-cpu                     # Partition/queue to submit job to
###
### # --- Variables ---
### # Path to project directory:
### Project="/scratch4/workspace/biancani_uri_edu-LociSimulation"
### # Path to scripts directory:
### Scripts="$Project/LociSimulation/Scripts"
### # Path to modified.write.tree2.R (script that adjusts how ape handles tree files)
### mod_write_tree2=$Scripts/2_simulation_scripts/modified.write.tree2.R
### # Path to output directory
### Output="$Project/output/mammals"
### # Path to treefile generated by 0.1_iqtree_empirical.sh
### treefile=$Output/0.1_empirical_tree/inferenceEmpirical.treefile
### # List of necessary R packages (separated by spaces)
### R_packages="igraph phangorn MASS clusterGeneration ape ggplot2 phytools geiger"
### # Total tree depth: Estimated age (in years) of most recent common ancestor of all species in the tree
### tree_depth=168000000
### # Generation time: Estimated generation time (in years) of all species in the tree:
### gen_time=4.5
### # Taxon (tip name) to use as the outgroup for rooting
### out_tip="Didelphis_virginiana"
### # Random number seeds for generate_params.txt
### simphy_seed1=12345
### simphy_seed2=67890
###
### # create output subdirectory:
### format_tree_out=$Output/1.0_formatted_empirical_tree
### mkdir -p $format_tree_out
### cd $format_tree_out
###
### module purge
### module load uri/main
### module load ImageMagick/7.1.1-15-GCCcore-12.3.0 # system dependency for the R 'magick' package
### module load foss/2024a # Loads an updated toolchain to provide the required C++ library: GLIBCXX_3.4.32 (fixes GLIBCXX error)
### module load R/4.3.2-gfbf-2023a # Loads updated R version
### # This forces the linker to find the correct, newest C++ library that contains GLIBCXX_3.4.32.
### # This must be done AFTER module loading to override potential downgrades.
### export GLIBCXX_PATH="/modules/uri_apps/software/GCCcore/13.3.0/lib64"
### export LD_LIBRARY_PATH=$GLIBCXX_PATH:$LD_LIBRARY_PATH
###
### ## Install R packages
###
### # add local space for R packages (won't ask about install location):
### mkdir -p ~/R-packages
### export R_LIBS=~/R-packages
###
### # install R packages
### Rscript ${Scripts}/1_prep_empirical_tree/install.packages.R $R_packages
###
###
### ## Process Empirical tree
### Rscript $Scripts/1_prep_empirical_tree/empirical_tree_processor.R $mod_write_tree2 $treefile $format_tree_out $out_tip $tree_depth $gen_time $simphy_seed1 $simphy_seed2
###
### date
### ---------------------------------
### sbatch 1.0_format_tree.sh

Submitted batch job 50314567 - module Error
Error: failing to load the Rcpp.so library due to a missing GLIBCXX_3.4.32 symbol, was caused by a compiler mismatch on the HPC cluster. The R package Rcpp (required by ape) had been compiled using a newer version of the GNU Compiler Collection (GCC) than the one available to R at runtime (GCCcore/11.2.0). This was resolved by updating the Slurm script's module load strategy: we first load the newest available toolchain (foss/2024a) to provide the necessary, updated C++ shared libraries (libstdc++.so.6), and then load a compatible R module (R/4.3.2-gfbf-2023a). Crucially, we also forced the deletion and reinstallation of all local R packages (rm -rf ~/R-packages/*) to ensure they were compiled cleanly using the newly loaded, compatible foss/2024a toolchain.
FIX: Resolve GLIBCXX compiler mismatch in R environment - Updates 1.0_format_tree.sh to load the latest foss toolchain and forces R package reinstallation to fix dependency loading error.

sbatch 1.0_format_tree.sh
Submitted batch job 50314943 - module error
Error: The R package installation failed for geiger and phytools because two of their indirect dependencies, MASS and clusterGeneration, were not found or did not install correctly during the automated dependency resolution. This kind of failure is common on HPC systems when packages have many dependencies. The fix was to explicitly include the missing top-level dependency packages (MASS, clusterGeneration, and phytools) alongside the target packages (ape, ggplot2, geiger, ggtree) in the $R\_packages variable in the Slurm script, forcing the clean reinstallation of all necessary components.
FIX: Explicitly list R package dependencies - Adds MASS, clusterGeneration, and phytools to R_packages variable in 1.0_format_tree.sh to resolve dependency failures for geiger during installation.

sbatch 1.0_format_tree.sh
Submitted batch job 50315543 - module Error
Error: The R package installation failed because the latest version of the MASS package requires R version ≥4.4.0, which is incompatible with the cluster's available R 4.3.2 module. The previous attempt to pin the version failed because install.packages() ignores the version argument when using the main CRAN mirror.
The definitive fix required opening an interactive session (see below) to install MASS version 7.3-60 (a compatible version) by pointing directly to its source file on the CRAN Archive URL (repos = NULL). This forces the installation of the correct package version, resolving the R version compatibility conflict and allowing dependent packages like geiger to install successfully.

# --- Install MASS separately with a pinned, compatible version for R 4.3.2 ---
# Version 7.3-60 is compatible with R 4.3.x
salloc # open interactive session
module purge
module load uri/main
module load foss/2024a # Loads an updated toolchain to provide the required C++ library: GLIBCXX_3.4.32 (fixes GLIBCXX error)
module load R/4.3.2-gfbf-2023a # Loads updated R version
export R_LIBS=~/R-packages
R
# --- Install MASS using the direct archive URL (CRITICAL FIX) ---
# This forces the download of the compatible version (7.3-60) for R 4.3.2.
install.packages("https://cran.r-project.org/src/contrib/Archive/MASS/MASS_7.3-60.tar.gz",
                 repos = NULL, # MUST be NULL when installing from a URL
                 type = "source",
                 dependencies = TRUE)

sbatch 1.0_format_tree.sh
Submitted batch job 50315977 - Error
The installation of the R package magick failed because the compiler could not find the external system development files (Magick++.h and the corresponding libraries).
Error: <stdin>:1:10: fatal error: Magick++.h: No such file or directory
Cause: The ImageMagick system library and its development headers are not in your environment's default search paths (neither via a simple module nor the base system).
The R package installation encountered two simultaneous failures:
System Dependency Failure: The R package magick failed to compile because its external system dependency, the ImageMagick development library (Magick++.h), was not found in the environment's default search path.
Recurring Compiler Mismatch: The GLIBCXX_3.4.32 error reappeared for phytools (via igraph) because the conflicting uri/main module was loaded before the necessary foss/2024a toolchain, resulting in a library downgrade.
The fix required a final comprehensive adjustment to the module load order in the Slurm script: explicitly loading the ImageMagick/7.1.1-15-GCCcore-12.3.0 module to provide the missing system headers, and ensuring the foss/2024a toolchain is loaded last to correctly define the newest C++ library environment. This ensures all low-level, system, and R-version-specific dependencies are correctly satisfied.
FIX: Resolve final compilation/dependency errors - Loads ImageMagick module to provide system headers for R 'magick' package, and finalizes module load order (foss/2024a last) to fix recurring GLIBCXX compiler downgrade error

sbatch 1.0_format_tree.sh
Submitted batch job 50316544 - Error
More dependency issues. Try adding igraph to list of R packages

sbatch 1.0_format_tree.sh
Submitted batch job 50316710 - Error
The core problem was a persistent compiler linking error (GLIBCXX_3.4.32 not found), which manifested across multiple R package installations (igraph, phangorn, phytools). Although the correct, newest compiler toolchain (foss/2024a) was loaded, the conflicting uri/main system module or standard library search paths kept defaulting to an older, incompatible library (GCCcore/12.3.0). The definitive fix was to use the path retrieved via module show to manually update the linker path. The Slurm script now explicitly sets LD\_LIBRARY\_PATH to prioritize the directory containing the newest C++ libraries (/modules/uri\_apps/software/GCCcore/13.3.0/lib64), forcing the system to link all new R packages correctly and resolving the chronic loading error.
FIX: Resolve chronic GLIBCXX linking error - Forces the LD_LIBRARY_PATH in 1.0_format_tree.sh to the newest GCCcore path (/modules/uri_apps/software/GCCcore/13.3.0/lib64). This overrides system defaults and fixes the recurring GLIBCXX_3.4.32 linker failure across all compiled R packages.

sbatch 1.0_format_tree.sh
Submitted batch job 50316861 - Error

# --- Install devtools and ggtree (via interactive session) ---
salloc
module purge
module load uri/main
module load foss/2024a # Loads an updated toolchain to provide the required C++ library: GLIBCXX_3.4.32 (fixes GLIBCXX error)
module load R/4.3.2-gfbf-2023a # Loads updated R version
export GLIBCXX_PATH="/modules/uri_apps/software/GCCcore/13.3.0/lib64"
export LD_LIBRARY_PATH=$GLIBCXX_PATH:$LD_LIBRARY_PATH
export R_LIBS=~/R-packages
R
# 1. Install devtools (needed for install_github)
if (!requireNamespace("devtools", quietly = TRUE)) {
    install.packages("devtools", dependencies = TRUE, repos = "https://cloud.r-project.org")
}
# 2. Load devtools
library(devtools)
# 3. Install ggtree from GitHub (this often bypasses strict CRAN/Bioconductor version checks)
# Note: You may also need to install the 'BiocManager' package first if this fails.
install_github("YuLab-SMU/ggtree")

sbatch 1.0_format_tree.sh
Submitted batch job 50317295 - worked!!

sacct -j 50317295 -o JobID,ExitCode,Elapsed,MaxRSS
JobID        ExitCode    Elapsed     MaxRSS
------------ -------- ---------- ----------
50317295          0:0   00:00:24
50317295.ba+      0:0   00:00:24    428496K
50317295.ex+      0:0   00:00:24          0

* Check re-rooted and ultrametric trees! - Issue. only rooting with one taxa instead of entire outgroup.
Thoughts:
As of now the tree is being rooted by specifying out_tip (tip name to use as the outgroup for rooting). However, many trees have a clade as an outgroup, not a single taxa. I know ggtree can root using a node instead of a taxon:
rooted_tree <- root(tree, node=109, resolve.root = TRUE, edgelabel=TRUE)
However, I don't know the node number for my outgroup.
The following code would produce a tree where the nodes are labeled with their node numbers, but I'd need to manually look at the tree and see what the outgroup node is labeled.
t <- ggtree(tree, layout="rectangular", size=1, branch.length="none") + geom_text(aes(label=node)) + geom_tiplab(align=TRUE, hjust=-.15)
What I would like to do, is write an R ggtree function or similar that takes a list of all the outgroup taxa and returns the number of the node the represents the common ancestor for those taxa (which would subsequently be used for rooting the tree)
To root a phylogenetic tree using an entire outgroup clade instead of a single taxon, the manual lookup of node numbers in a ggtree plot is unnecessary. The required functionality is available in the ape package, which is already loaded in the script. The function to use is getMRCA() (Most Recent Common Ancestor). This function efficiently takes two arguments: the phylogenetic tree object and a vector containing the names of all the outgroup tip labels. It then automatically returns the specific node index corresponding to the common ancestor of that entire outgroup clade. This node index can then be passed directly to the root() function for accurate clade-based rooting.

To transition from rooting the phylogenetic tree using a single taxon to using an entire outgroup clade, the script was updated to leverage the ape::getMRCA() function. This involved two main changes:
Input Change: The command-line argument $out_tip was replaced with a string of comma-separated outgroup taxa (e.g., Didelphis_virginiana,Monodelphis_domestica).
R Logic: The empirical_tree_processor.R script was modified to:
Parse the input string into an R vector of tip labels using strsplit().
Use getMRCA(tree, tip = outgroup_taxa) to programmatically find the integer node index corresponding to the most recent common ancestor of all specified outgroup tips.
Replace the single-taxon root(..., outgroup=...) call with the root(..., node=outgroup_node) call, ensuring the tree is rooted correctly on the ancestral node of the entire outgroup clade.

Making updates scripts...

FEAT: Implement clade-based tree rooting via MRCA
Replaces single-taxon rooting with support for multi-taxa outgroups. Uses ape::getMRCA() to find the common ancestor node index for a comma-separated list of outgroup tips, ensuring accurate clade-based tree rooting.

cd /scratch4/workspace/biancani_uri_edu-LociSimulation/LociSimulation/Scripts/1_prep_empirical_tree

nano empirical_tree_processor.R
---------------------------------
## Capture Command Line Arguments

# Arguments must be passed in the following order:
# [1] mod_write_tree2     (Path to modified.write.tree2.R - script that adjusts how ape handles tree files)
# [2] treefile            (Path to the input .treefile - generated by 0.1_iqtree_empirical.sh)
# [3] format_tree_out     (Base directory for output files)
# [4] outgroup            (List of comma separated outgroup taxa for tree rooting)
# [5] tree_depth          (Estimated age in years of most recent common ancestor of all species in the tree)
# [6] gen_time            (Estimated generation time in years for all species in the tree)
# [7] simphy_seed1        (First random number seed for generate_params.txt)
# [8] simphy_seed2        (Second random number seed for generate_params.txt)

args <- commandArgs(trailingOnly = TRUE)

# Check if the correct number of arguments was provided
if (length(args) < 8) {
  stop("Error: Not enough arguments provided. Expected 8.", call. = FALSE)
}

# Assign arguments to variables
mod_write_tree2 <- args[1]
treefile <- args[2]
format_tree_out <- args[3]
outgroup <- args[4]
simphy_seed1 <- args[7]
simphy_seed2 <- args[8]

# Calculate the scale factor (Total Generations) from args[5] (depth) and args[6] (gen_time)
scale_factor <- as.numeric(args[5])/as.numeric(args[6])

# --- 2. Load Libraries and Setup ---

library(ape)
library(ggplot2)
library(geiger)
library(ggtree)

## Force a headless friendly bitmap device for the session
options(bitmapType = "cairo")

# Adjust path to modified.write.tree2.R
source(mod_write_tree2)
assignInNamespace(".write.tree2", .write.tree2, "ape")

# --- 3. Process and Save Empirical Tree ---

# Empirical tree:
tree <- read.tree(treefile)

# 1. Convert the comma-separated string into a vector of tip labels
outgroup_taxa <- unlist(strsplit(outgroup, ","))

# 2. Check that the taxa are actually in the tree
if (!all(outgroup_taxa %in% tree$tip.label)) {
    # Check if any taxa in the list are missing from the tree
    missing_taxa <- setdiff(outgroup_taxa, tree$tip.label)
    stop(paste("Error: The following outgroup taxa were not found in the tree:", paste(missing_taxa, collapse=", ")), call.=FALSE)
}

# 3. Find the Most Recent Common Ancestor (MRCA) node index
# getMRCA returns the node index that is ancestral to all tips in the vector
outgroup_node <- getMRCA(phy = tree, tip = outgroup_taxa)

# 4. Root the tree using the identified MRCA node index
# Use the node= argument instead of outgroup=
tree <- root(tree, node = outgroup_node, resolve.root = TRUE)

# Save the check image
p <- ggtree(tree) + theme_tree2() + geom_tiplab()
ggsave(p, file=paste0(format_tree_out, "/tree_check_root.png"))

# Check the tree rooted correctly. Then transform to ultrametric and rescale

tree_um <- chronos(tree)
class(tree_um) <- "phylo" # Ensure it is a 'phylo' object after chronos
tree_um <- rescale(tree_um, model = "depth", scale_factor)

# Save the ultrametric tree check image
q <- ggtree(tree_um) + theme_tree2() + geom_tiplab()
ggsave(q, file=paste0(format_tree_out, "/tree_um.png"))

# --- 4. Prepare for SimPhy and Write Outputs ---

# Replace labels with numbers, strip node labels, and write out the tree
tree_um$tip.label <- as.character(1:length(tree_um$tip.label))
tree_um$node.label <- NULL
write.tree(tree_um, paste0(format_tree_out, "/s_tree.trees"), digits=8)

# Write the seeds for subsequent dataset parameter simulations
write(c(simphy_seed1, simphy_seed2), paste0(format_tree_out, "/generate_params.txt"))

print("Tree processing complete and output files saved.")
---------------------------------

cd /scratch4/workspace/biancani_uri_edu-LociSimulation/LociSimulation/Scripts/1_prep_empirical_tre

nano 1.0_format_tree.sh
---------------------------------
#!/bin/bash
#SBATCH --job-name="process_tree"
#SBATCH --time=72:00:00                # Walltime limit (HH:MM:SS)
#SBATCH --nodes=1                      # Number of nodes
#SBATCH --ntasks=1                     # Total number of tasks (processes)
#SBATCH --cpus-per-task=2              # Number of CPU cores per task
#SBATCH --mem-per-cpu=6G               # Memory per cpu
#SBATCH --mail-user="biancani@uri.edu" # CHANGE TO user email address
#SBATCH --mail-type=ALL
#SBATCH -p uri-cpu                     # Partition/queue to submit job to

# --- Variables ---
# Path to project directory:
Project="/scratch4/workspace/biancani_uri_edu-LociSimulation"
# Path to scripts directory:
Scripts="$Project/LociSimulation/Scripts"
# Path to modified.write.tree2.R (script that adjusts how ape handles tree files)
mod_write_tree2=$Scripts/2_simulation_scripts/modified.write.tree2.R
# Path to output directory
Output="$Project/output/mammals"
# Path to treefile generated by 0.1_iqtree_empirical.sh
treefile=$Output/0.1_empirical_tree/inferenceEmpirical.treefile
# List of necessary R packages (separated by spaces)
R_packages="igraph phangorn MASS clusterGeneration ape ggplot2 phytools geiger"
# List of outgroup taxa for tree rooting (comma separated)
outgroup="Wallabia_bicolor,Potorous_gilbertii,Pseudochirops_corinnae,Gymnobelideus_leadbeateri,Phalanger_gymnotis,Vombatus_ursinus,Phascolarctos_cinereus,Thylacinus_cynocephalus,Sarcophilus_harrisii,Didelphis_virginiana"
# Total tree depth: Estimated age (in years) of most recent common ancestor of all species in the tree
tree_depth=168000000
# Generation time: Estimated generation time (in years) of all species in the tree:
gen_time=4.5
# Random number seeds for generate_params.txt
simphy_seed1=12345
simphy_seed2=67890

# create output subdirectory:
format_tree_out=$Output/1.0_formatted_empirical_tree
mkdir -p $format_tree_out
cd $format_tree_out

module purge
module load uri/main
module load ImageMagick/7.1.1-15-GCCcore-12.3.0 # system dependency for the R 'magick' package
module load foss/2024a # Loads an updated toolchain to provide the required C++ library: GLIBCXX_3.4.32 (fixes GLIBCXX error)
module load R/4.3.2-gfbf-2023a # Loads updated R version
# This forces the linker to find the correct, newest C++ library that contains GLIBCXX_3.4.32.
# This must be done AFTER module loading to override potential downgrades.
export GLIBCXX_PATH="/modules/uri_apps/software/GCCcore/13.3.0/lib64"
export LD_LIBRARY_PATH=$GLIBCXX_PATH:$LD_LIBRARY_PATH

## Install R packages

# add local space for R packages (won't ask about install location):
mkdir -p ~/R-packages
export R_LIBS=~/R-packages

# install R packages
Rscript ${Scripts}/1_prep_empirical_tree/install.packages.R $R_packages


## Process Empirical tree
Rscript $Scripts/1_prep_empirical_tree/empirical_tree_processor.R $mod_write_tree2 $treefile $format_tree_out $outgroup $tree_depth $gen_time $simphy_seed1 $simphy_seed2

date
---------------------------------
sbatch 1.0_format_tree.sh
Submitted batch job 50427601
sacct -j 50427601 -o JobID,ExitCode,Elapsed,MaxRSS
JobID        ExitCode    Elapsed     MaxRSS
------------ -------- ---------- ----------
50427601          0:0   00:00:42
50427601.ba+      0:0   00:00:42    379772K
50427601.ex+      0:0   00:00:42          0 
